# ACM
ACM
/***************************
二十进制数的加法和的求法：（会二十进制后不管多少进制应该都是类似的） 
1.先将输入的两个二十进制数分别都转化为数字
2.进行数字的加减法
3.数字加好后在判别是在0~9还是10~19之间即可
4.满足20就进一
注意点：如果不将输入的数组倒置的话，可能在最最左边一位进一的时候
就出现了溢出，所以现在只要满足条件往右进一即可 
***************************/
#include<bits/stdc++.h> 
using namespace std;
int main ()
{
    char s1[105],s2[105];//s1,s2数组为输入的二十进制的数 
    int a[105],b[105],c[105];//a,b数组是将s1,s2数组转换为数字进行记录，c数组是用来存放a，b两个数组加起来的结果 
    int k,m,n,x,ans,flag;
    while(~scanf("%s %s",s1,s2))//对 s1,s2的二十进制数的输入 
    {	
        memset(a,0,sizeof(a));//先对要存储的数组进行清零操作 
        memset(b,0,sizeof(b));
        memset(c,0,sizeof(c));
        int len1=strlen(s1),len2=strlen(s2);//求出二十进制数组的长度 
        for(int i=len1-1;i>=0;i--)//将二十进制数全部变成10进制数 
        {							  //a，b数组到着进行赋值，考虑到如果正序赋值的话，接下来往前进一的话会产生越位 
            if(s1[i]>='0'&&s1[i]<='9')//这样的话就是往后进一，不会产生影响 
                a[len1-1-i]=s1[i]-'0'; 
            else if(s1[i]>='a'&&s1[i]<='j')
                a[len1-1-i]=s1[i]-'a'+10;
        }
        for(int i=len2-1;i>=0;i--)
        {
            if(s2[i]>='0'&&s2[i]<='9')
               b[len2-1-i]=s2[i]-'0';//字符减去字符就变成了一个数 
            else if(s2[i]>='a'&&s2[i]<='j')
               b[len2-1-i]=s2[i]-'a'+10;//进行数字操作 
        }
        int len=max(len1,len2);
        for(int i=0;i<len;i++)
        {
            c[i]=a[i]+b[i]+c[i];//将两个十进制数组加到第三个c数组里面； 
            if(c[i]>=20)
            {
              c[i]=c[i]-20;//将加起来超过20的位数进行处理 
              c[i+1]++;//这种进位 比较奇葩，往右进位的，与上方的操作进行对应 
            }
        }
        int l=max(len1,len2)+2;//求长度最长的两个字符数组 
        while(c[l]==0)//用来排除0字符串的出现,这种操作要学一下			
            l--;
        if(l<0)
           printf("0\n");
        else
        {
            for(int i=l;i>=0;i--)//用来输出，字符跟数字混合输出 
            {
                if(c[i]<=9)
                   printf("%d",c[i]);
                else
                    printf("%c",c[i]-10+'a');//重新变成字符 
            }
            printf("\n");
        }
    }
    return 0;
}
